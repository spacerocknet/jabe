package spacerock.utils

import play.api.libs.Crypto
import scaldi.{Injectable, Injector}
import spacerock.cache.redis.RedisWrapper
import spacerock.constants.Constants
import spacerock.persistence.cassandra.ServerInfo

import scala.collection.mutable

/**
 * Created by william on 2/24/15.
 */

trait IdGenerator {
  def generateNextId(key: String): Long
  def generateNextBlock(key: String, amount: Int): Set[Long]
  def generateNextBlock(amount: Int): Set[String]
  def generateAuthCode(uid: String, expiredTime: Long): String
  def generateAuthCode(): String
}

/**
 * This class is for generating id, uid. It uses redis key internally.
 * UID is the 64-bit key, with customized random-increment integer as implemented in @method genIdFromLong
 * @param inj
 */
class UidGenerator (implicit inj: Injector) extends IdGenerator with Injectable {
  final val idFmt: String = "%d%d%d"

  val rw: RedisWrapper = inject [RedisWrapper]
  val si: ServerInfo = inject [ServerInfo]
  final val SUFFIX_SEED_NUMBER: Int = 4096 // 12 bit
  final val PREFIX_SEED_NUMBER: Int = 8 // 3 bit ==> it should be a server identity
  final val HIGH_ORDER_BITS_FILTER: Long = 0x07FFFFFFFFFFF000L

  /**
   * Generate next id for a key.
   * @param key
   * @return
   */
  override def generateNextId(key: String): Long = {
    rw.getNextId(key)
  }

  /**
   * Generate next uid block for Jabe server base on timestamp, host-ip and seq number.
   * First, it connect to cassandra to get last seq number
   * and use that as a incremental seed to produce ids.
   * When the generation process is done, seq number of corresponding server will be updated.
   * @param amount amount of key will be generated
   * @return
   */
  override def generateNextBlock(amount: Int): Set[String] = {
    val result: mutable.HashSet[String] = new mutable.HashSet[String]
    var seq: Long = si.getSeqInfo(StaticVariables.serverIp)
    if (seq < 0)
      return null

    for (i <- 0 until amount) {
      result.add(genIdFromSeq(seq))
      seq = seq + 1
    }

    si.insertOrUpdateServerInfo(StaticVariables.serverIp, amount)
    result.toSet
  }

  /**
   * Generate next uid block for Jabe server base on timestamp, host-ip and seq number.
   * First, it connect to cassandra to get last seq number
   * and use that as a incremental seed to produce ids.
   * When the generation process is done, seq number of corresponding server will be updated.
   * @param key redis key in which the method based on to generate next seq number
   * @param amount amount of key will be generated
   * @return
   */
  override def generateNextBlock(key: String, amount: Int): Set[Long] = {
    val result: mutable.HashSet[Long] = new mutable.HashSet[Long]

    for (i <- 0 until amount) {
      result.add(genIdFromLong(rw.getValueFromKey(key)))
    }
    result.toSet
  }

  /**
   * Generate customized uid with integer as an input
   * @param n increment integer
   * @return customized uid from input integer
   */
  private def genIdFromLong(n: Long): Long = {

    val num: Long = (n << 12) & HIGH_ORDER_BITS_FILTER
    val r1: Int = CustomizedRandom.nextInt(SUFFIX_SEED_NUMBER)
    var r2: Long = CustomizedRandom.nextInt(PREFIX_SEED_NUMBER)
    r2 = (r2 << 59)
    var res: Long = num | r2
    res = res | r1
    res
  }

  private def genIdFromSeq(seq: Long): String = {
    val ts: Long = System.currentTimeMillis()
    idFmt.format(ts, StaticVariables.serverIpInt, seq)
  }

  /**
   * Decode customized uid generated by @method genIdFromLong
   * @param n customized uid
   * @return real uid
   */
  def decodeId(n: Long): Long = {
    val res = n & HIGH_ORDER_BITS_FILTER
    res >> 12
  }

  /**
   * Generate auth code from uid, expired time and a random key
   * @param uid user id
   * @param expiredTime code's expired time
   * @param n random integer
   * @return encrypted code
   */
  private def genAuthCodeFromLong(uid: String, expiredTime: Long, n: Long): String = {
    val fmt: String = "{%s-%d-%d}"
    val input: String = fmt.format(uid, expiredTime, n)
    Crypto.encryptAES(input, StaticVariables.pk)
  }

  /**
   * Generate auth code with uid, expiredTime
   * @param uid user id
   * @param expiredTime expired time
   * @return encrypted auth code
   */
  override def generateAuthCode(uid: String, expiredTime: Long): String = {
    val n: Long = CustomizedRandom.nextLong
    genAuthCodeFromLong(uid, expiredTime, n)
  }

  /**
   * Generate a signed token
   * @return
   */
  override def generateAuthCode(): String = {
    CustomizedRandom.nextBase64String(Constants.AUTH_CODE_LENGTH)
  }
}

